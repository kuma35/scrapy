# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008–2018, Scrapy developers
# This file is distributed under the same license as the Scrapy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Scrapy \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-04-10 01:26+0900\n"
"PO-Revision-Date: 2021-05-11 08:43+0900\n"
"Last-Translator: kuma35\n"
"Language-Team: Japanese\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../../topics/items.rst:5
msgid "Items"
msgstr "アイテム"

#: ../../topics/items.rst:10
msgid ""
"The main goal in scraping is to extract structured data from unstructured "
"sources, typically, web pages. :ref:`Spiders <topics-spiders>` may return "
"the extracted data as `items`, Python objects that define key-value pairs."
msgstr "スクレイピングの主な目標は、非構造化ソース(通常はWebページ)から構造化データを抽出することです。 :ref:`スパイダー <topics-spiders>` は、抽出されたデータを `アイテム`  、つまりkey-valueペアを定義するPythonオブジェクトとして返す場合があります。"

#: ../../topics/items.rst:14
msgid ""
"Scrapy supports :ref:`multiple types of items <item-types>`. When you create "
"an item, you may use whichever type of item you want. When you write code "
"that receives an item, your code should :ref:`work for any item type "
"<supporting-item-types>`."
msgstr "Scrapyは :ref:`複数のタイプのアイテム<item-types>` をサポートしています。 あなたがアイテムを作成したいときは、任意のタイプのアイテムを使用できます。 アイテムを受け取るコードを作成する場合、そのコードは :ref:`任意のアイテムタイプ<supporting-item-types>` で機能する必要があります。"

#: ../../topics/items.rst:22
msgid "Item Types"
msgstr "アイテム型"

#: ../../topics/items.rst:24
msgid ""
"Scrapy supports the following types of items, via the `itemadapter`_ "
"library: :ref:`dictionaries <dict-items>`, :ref:`Item objects <item-"
"objects>`, :ref:`dataclass objects <dataclass-items>`, and :ref:`attrs "
"objects <attrs-items>`."
msgstr "Scrapyは、 `itemadapter`_ ライブラリを介して以下の型のアイテムをサポートします: :ref:`辞書 <dict-items>` 、 :ref:`Item オブジェクト <item-objects>` 、 :ref:`dataclass オブジェクト <dataclass-items>` 、 :ref:`attrs オブジェクト <attrs-items>` 。"

#: ../../topics/items.rst:33
msgid "Dictionaries"
msgstr "辞書"

#: ../../topics/items.rst:35
msgid "As an item type, :class:`dict` is convenient and familiar."
msgstr "アイテム型として辞書( :class:`dict` )は便利でおなじみです。"

#: ../../topics/items.rst:40
msgid "Item objects"
msgstr "Itemオブジェクト"

#: ../../topics/items.rst:42
msgid ""
":class:`Item` provides a :class:`dict`-like API plus additional features "
"that make it the most feature-complete item type:"
msgstr ":class:`Item`  は :class:`dict` 風のAPIに加えて、アイテム型としての豊富な機能を提供します:"

#: ../../topics/items.rst:47
msgid ""
":class:`Item` objects replicate the standard :class:`dict` API, including "
"its ``__init__`` method."
msgstr ":class:`Item` オブジェクトは、``__init__`` メッソドを含む標準の :class:`dict` APIを複製(replicate)します。"

#: ../../topics/items.rst:50
msgid ":class:`Item` allows defining field names, so that:"
msgstr ":class:`Item` ではフィールド名を定義できるため、以下のようになります:"

#: ../../topics/items.rst:52
msgid ""
":class:`KeyError` is raised when using undefined field names (i.e. prevents "
"typos going unnoticed)"
msgstr ":class:`KeyError` は、未定義のフィールド名を使用すると発生(raise)します(つまり、タイプミスが見過ごされないようにします)"

#: ../../topics/items.rst:55
msgid ""
":ref:`Item exporters <topics-exporters>` can export all fields by default "
"even if the first scraped object does not have values for all of them"
msgstr ":ref:`アイテム・エクスポーター <topics-exporters>` は、最初にスクレイプされたオブジェクトにすべてのフィールドの値が揃ってない場合でも、デフォルト値をセットしてすべてのフィールドをエクスポートできます"

#: ../../topics/items.rst:59
msgid ""
":class:`Item` also allows defining field metadata, which can be used to :ref:"
"`customize serialization <topics-exporters-field-serialization>`."
msgstr ":class:`Item` はフィールド・メタ・データを定義することもできます。これは :ref:`シリアライズのカスタマイズ <topics-exporters-field-serialization>` に使用できます。"

#: ../../topics/items.rst:62
msgid ""
":mod:`trackref` tracks :class:`Item` objects to help find memory leaks (see :"
"ref:`topics-leaks-trackrefs`)."
msgstr ":mod:`trackref` は、 :class:`Item` を追跡しメモリ・リークを見つけるのに役立ちます(see :ref:`topics-leaks-trackrefs`)。"

#: ../../topics/items.rst:65
msgid ""
":class:`Item` objects also provide the following additional API members:"
msgstr ":class:`Item` オブジェクトは、以下の追加APIメンバーも提供します:"

#: ../../../scrapy/item.py:docstring of scrapy.item.DictItem.deepcopy:1
msgid "Return a :func:`~copy.deepcopy` of this item."
msgstr "このアイテムの :func:`~copy.deepcopy` を返す。"

#: ../../topics/items.rst:73
msgid ""
"A dictionary containing *all declared fields* for this Item, not only those "
"populated. The keys are the field names and the values are the :class:"
"`Field` objects used in the :ref:`Item declaration <topics-items-declaring>`."
msgstr ""
"読み込まれたフィールドだけでなく、このアイテムの *すべての宣言済みフィールド"
"* を含む辞書。 キーはフィールド名で、値は :ref:`アイテム宣言<topics-items-"
"declaring>` で使用される :class:`Field` オブジェクトです。"

#: ../../topics/items.rst:78 ../../topics/items.rst:109
#: ../../topics/items.rst:140
msgid "Example::"
msgstr "例::"

#: ../../topics/items.rst:89
msgid "Dataclass objects"
msgstr "Dataclassオブジェクト"

#: ../../topics/items.rst:93
msgid ""
":func:`~dataclasses.dataclass` allows defining item classes with field "
"names, so that :ref:`item exporters <topics-exporters>` can export all "
"fields by default even if the first scraped object does not have values for "
"all of them."
msgstr ":func:`~dataclasses.dataclass` を使用すると、フィールド名を使用してアイテム・クラスを定義できるため、 :ref:`アイテム・エクスポーター <topics-exporters>` は、最初にスクレイプされたオブジェクトにすべての値がない場合でも、デフォルトでそれらすべてのフィールドをエクスポートできます。"

#: ../../topics/items.rst:97
msgid "Additionally, ``dataclass`` items also allow to:"
msgstr "さらに、 ``dataclass`` アイテムは以下も可能にします:"

#: ../../topics/items.rst:99 ../../topics/items.rst:133
msgid "define the type and default value of each defined field."
msgstr "定義された各フィールドの型とデフォルト値を定義します。"

#: ../../topics/items.rst:101
msgid ""
"define custom field metadata through :func:`dataclasses.field`, which can be "
"used to :ref:`customize serialization <topics-exporters-field-"
"serialization>`."
msgstr ":func:`dataclasses.field` を介してカスタム・フィールド・メタ・データを定義します。これは、 :ref:`シリアル化のカスタマイズ <topics-exporters-field-serialization>` に使用できます。"

#: ../../topics/items.rst:104
msgid ""
"They work natively in Python 3.7 or later, or using the `dataclasses "
"backport`_ in Python 3.6."
msgstr "これらはPython3.7以降はネイティブに機能します。また、Python3.6では `dataclasses backport`_ を使用します。"

#: ../../topics/items.rst:118
msgid "Field types are not enforced at run time."
msgstr "フィールド型は実行時に強要されません。"

#: ../../topics/items.rst:123
msgid "attr.s objects"
msgstr "attr.sオブジェクト"

#: ../../topics/items.rst:127
msgid ""
":func:`attr.s` allows defining item classes with field names, so that :ref:"
"`item exporters <topics-exporters>` can export all fields by default even if "
"the first scraped object does not have values for all of them."
msgstr ":func:`attr.s` を使用すると、フィールド名を使用してアイテム・クラスを定義できるため、 :ref:`アイテム・エクスポーター <topics-exporters>` は、最初にスクレイプされたオブジェクトにすべてのフィールドの値がない場合でも、デフォルトですべてのフィールドをエクスポートできます。"

#: ../../topics/items.rst:131
msgid "Additionally, ``attr.s`` items also allow to:"
msgstr "さらに、 ``attr.s`` アイテムは以下も可能にします:"

#: ../../topics/items.rst:135
msgid ""
"define custom field :ref:`metadata <attrs:metadata>`, which can be used to :"
"ref:`customize serialization <topics-exporters-field-serialization>`."
msgstr "カスタムフィールド :ref:`metadata <attrs:metadata>` を定義します。これは :ref:`シリアル化のカスタマイズ <topics-exporters-field-serialization>` に使用できます。"

#: ../../topics/items.rst:138
msgid ""
"In order to use this type, the :doc:`attrs package <attrs:index>` needs to "
"be installed."
msgstr "この型を使用するには、 :doc:`attrsパッケージ <attrs:index>` をインストールする必要があります。"

#: ../../topics/items.rst:151 ../../topics/items.rst:219
msgid "Working with Item objects"
msgstr "Itemオブジェクトで作業する"

#: ../../topics/items.rst:156
msgid "Declaring Item subclasses"
msgstr "Itemサブクラス宣言"

#: ../../topics/items.rst:158
msgid ""
"Item subclasses are declared using a simple class definition syntax and :"
"class:`Field` objects. Here is an example::"
msgstr "Itemsサブクラスは、単純なクラス定義構文と :class:`Field` オブジェクトを使用して宣言します。 以下に例を示します::"

#: ../../topics/items.rst:170
msgid ""
"Those familiar with `Django`_ will notice that Scrapy Items are declared "
"similar to `Django Models`_, except that Scrapy Items are much simpler as "
"there is no concept of different field types."
msgstr ""
"`Django`_ に精通している人は、Scrapyアイテムが `Django Models`_ と同様に宣言"
"されていることに気付くでしょう。ただし、異なるフィールド型の概念がないため、"
"Scrapyアイテムははるかに単純です。"

#: ../../topics/items.rst:181
msgid "Declaring fields"
msgstr "フィールド宣言"

#: ../../topics/items.rst:183
msgid ""
":class:`Field` objects are used to specify metadata for each field. For "
"example, the serializer function for the ``last_updated`` field illustrated "
"in the example above."
msgstr ""
":class:`Field` オブジェクトは、各フィールドのメタ・データを指定するために使用"
"されます。 たとえば、上記の例で示した ``last_updated`` フィールドのシリアル化"
"関数です。"

#: ../../topics/items.rst:187
msgid ""
"You can specify any kind of metadata for each field. There is no restriction "
"on the values accepted by :class:`Field` objects. For this same reason, "
"there is no reference list of all available metadata keys. Each key defined "
"in :class:`Field` objects could be used by a different component, and only "
"those components know about it. You can also define and use any other :class:"
"`Field` key in your project too, for your own needs. The main goal of :class:"
"`Field` objects is to provide a way to define all field metadata in one "
"place. Typically, those components whose behaviour depends on each field use "
"certain field keys to configure that behaviour. You must refer to their "
"documentation to see which metadata keys are used by each component."
msgstr ""
"あなたは各フィールドに任意の種類のメタ・データを指定できます。 :class:"
"`Field` オブジェクトが受け入れる値には制限はありません。これと同じ理由で、利"
"用可能なすべてのメタ・データ・キーの参照リストはありません。 :class:`Field` "
"オブジェクトで定義された各キーは異なるコンポーネントで使用でき、それらのコン"
"ポーネントのみがそれについて知っています。プロジェクトで他の :class:`Field` "
"キーを定義して使用することもできます。 :class:`Field` オブジェクトの主な目的"
"は、すべてのフィールド・メタ・データを1か所で定義する方法を提供することで"
"す。 通常、各フィールドに動作が依存するコンポーネントは、特定のフィールド・"
"キーを使用してその動作を構成します。 各コンポーネントで使用されているメタ・"
"データ・キーを確認するには、ドキュメントを参照する必要があります。"

#: ../../topics/items.rst:198
msgid ""
"It's important to note that the :class:`Field` objects used to declare the "
"item do not stay assigned as class attributes. Instead, they can be accessed "
"through the :attr:`Item.fields` attribute."
msgstr ""
"アイテムの宣言に使用される :class:`Field` オブジェクトは、クラス属性として割"
"り当てられたままにならないことに注意することが重要です。 代わりに、 :attr:"
"`Item.fields` 属性を介してアクセスできます。"

#: ../../topics/items.rst:204
msgid ""
"The :class:`Field` class is just an alias to the built-in :class:`dict` "
"class and doesn't provide any extra functionality or attributes. In other "
"words, :class:`Field` objects are plain-old Python dicts. A separate class "
"is used to support the :ref:`item declaration syntax <topics-items-"
"declaring>` based on class attributes."
msgstr ":class:`Field` クラスは組み込みの :class:`dict` クラスの単なるエイリアスであり、追加の機能や属性を提供しません。 言い換えれば、 :class:`Field` オブジェクトは昔ながらのPython辞書です。 別のクラスを使用して、クラス属性に基づいて :ref:`アイテム宣言構文<topics-items-declaring>` をサポートします。"

#: ../../topics/items.rst:210
msgid ""
"Field metadata can also be declared for ``dataclass`` and ``attrs`` items. "
"Please refer to the documentation for `dataclasses.field`_ and `attr.ib`_ "
"for additional information."
msgstr "metadataフィールドは、 ``dataclass`` と ``attrs`` アイテムに対しても宣言できます。 詳細については、 `dataclasses.field`_ と `attr.ib`_ の文書を参照してください。"

#: ../../topics/items.rst:221
msgid ""
"Here are some examples of common tasks performed with items, using the "
"``Product`` item :ref:`declared above  <topics-items-declaring>`. You will "
"notice the API is very similar to the :class:`dict` API."
msgstr "ここで、 :ref:`先程宣言した<topics-items-declaring>` ``Product`` アイテムを使って、アイテムで実行される一般的なタスクの例をいくつか示します。 APIは :class:`dict` APIに非常に似ていることに気付くでしょう。"

#: ../../topics/items.rst:226
msgid "Creating items"
msgstr "アイテムの作成"

#: ../../topics/items.rst:234
msgid "Getting field values"
msgstr "フィールド値の取得"

#: ../../topics/items.rst:274
msgid "Setting field values"
msgstr "フィールド値のセット"

#: ../../topics/items.rst:287
msgid "Accessing all populated values"
msgstr "読み込まれたすべての値へのアクセス"

#: ../../topics/items.rst:289
msgid "To access all populated values, just use the typical :class:`dict` API:"
msgstr "読み込まれたすべての値にアクセスするには、典型的な :class:`dict` API を使用するだけです:"

#: ../../topics/items.rst:301
msgid "Copying items"
msgstr "アイテムのコピー"

#: ../../topics/items.rst:303
msgid ""
"To copy an item, you must first decide whether you want a shallow copy or a "
"deep copy."
msgstr ""
"アイテムをコピーするには、あなたは最初に浅いコピーとディープ・コピーのどちら"
"を使用するかを決定する必要があります。"

#: ../../topics/items.rst:306
msgid ""
"If your item contains :term:`mutable` values like lists or dictionaries, a "
"shallow copy will keep references to the same mutable values across all "
"different copies."
msgstr "アイテムにリストや辞書などのミュータブル( :term:`mutable` )値が含まれている場合、浅いコピーは、すべての異なるコピー間で同じミュータブル値への参照を保持します。"

#: ../../topics/items.rst:310
msgid ""
"For example, if you have an item with a list of tags, and you create a "
"shallow copy of that item, both the original item and the copy have the same "
"list of tags. Adding a tag to the list of one of the items will add the tag "
"to the other item as well."
msgstr ""
"たとえば、タグのリストを持つアイテムがあり、そのアイテムの浅いコピーを作成す"
"る場合、元のアイテムとコピーの両方に同じタグのリストがあります。 アイテムの1"
"つのリストにタグを追加すると、他のアイテムにもタグが追加されます。"

#: ../../topics/items.rst:315
msgid "If that is not the desired behavior, use a deep copy instead."
msgstr ""
"それが望ましい振る舞いでない場合は、代わりにディープ・コピーを使用します。"

#: ../../topics/items.rst:317
msgid "See :mod:`copy` for more information."
msgstr "詳細は :mod:`copy` 参照。"

#: ../../topics/items.rst:319
msgid ""
"To create a shallow copy of an item, you can either call :meth:`~scrapy.item."
"Item.copy` on an existing item (``product2 = product.copy()``) or "
"instantiate your item class from an existing item (``product2 = "
"Product(product)``)."
msgstr ""
"アイテムの浅いコピーを作成するには、あなたは、既存のアイテムで :meth:"
"`~scrapy.item.Item.copy` を呼び出す(``product2 = product.copy()``)か、あるい"
"は、既存のアイテムからアイテム・クラスをインスタンス化(``product2 = "
"Product(product)``)のいずれかが可能です。"

#: ../../topics/items.rst:324
msgid ""
"To create a deep copy, call :meth:`~scrapy.item.Item.deepcopy` instead "
"(``product2 = product.deepcopy()``)."
msgstr ""
"ディープ・コピーを作成するには、代わりに :meth:`~scrapy.item.Item.deepcopy` "
"を呼び出します(``product2 = product.deepcopy()``)。"

#: ../../topics/items.rst:329
msgid "Other common tasks"
msgstr "その他の一般的な作業"

#: ../../topics/items.rst:331
msgid "Creating dicts from items:"
msgstr "アイテムから辞書を作成する:"

#: ../../topics/items.rst:336
msgid "Creating items from dicts:"
msgstr "辞書からアイテムを作成する:"

#: ../../topics/items.rst:348
msgid "Extending Item subclasses"
msgstr "Itemサブクラスの拡張"

#: ../../topics/items.rst:350
msgid ""
"You can extend Items (to add more fields or to change some metadata for some "
"fields) by declaring a subclass of your original Item."
msgstr ""
"あなたは、元のアイテムのサブクラスを宣言することにより、アイテムを拡張できま"
"す(フィールドを追加したり、フィールドのメタ・データを変更したりできます)。"

#: ../../topics/items.rst:353
msgid "For example::"
msgstr "例えば::"

#: ../../topics/items.rst:359
msgid ""
"You can also extend field metadata by using the previous field metadata and "
"appending more values, or changing existing values, like this::"
msgstr ""
"次のように、あなたは、以前のフィールド・メタ・データを使用して値を追加した"
"り、既存の値を変更したりして、フィールド・メタ・データを拡張することもできま"
"す::"

#: ../../topics/items.rst:365
msgid ""
"That adds (or replaces) the ``serializer`` metadata key for the ``name`` "
"field, keeping all the previously existing metadata values."
msgstr ""
"これは、 ``name`` フィールドの ``serializer`` メタ・データ・キーを追加(または"
"置換)し、以前に存在したすべてのメタ・データ値を保持します。"

#: ../../topics/items.rst:372
msgid "Supporting All Item Types"
msgstr "全アイテム型のサポート"

#: ../../topics/items.rst:374
msgid ""
"In code that receives an item, such as methods of :ref:`item pipelines "
"<topics-item-pipeline>` or :ref:`spider middlewares <topics-spider-"
"middleware>`, it is a good practice to use the :class:`~itemadapter."
"ItemAdapter` class and the :func:`~itemadapter.is_item` function to write "
"code that works for any :ref:`supported item type <item-types>`:"
msgstr ":ref:`アイテム・パイプライン <topics-item-pipeline>` または :ref:`スパイダー・ミドルウェア <topics-spider-middleware>` のメソッドなど、アイテムを受け取るコードでは、任意の :ref:`サポートされているアイテム型 <item-types>` で機能するコードを書くために :class:`~itemadapter.ItemAdapter` クラスと :func:`~itemadapter.is_item` 関数を使用することをお勧めします。"

#: ../../../venv/lib/python3.8/site-packages/itemadapter/adapter.py:docstring
#: of itemadapter.adapter.ItemAdapter:1
msgid ""
"Wrapper class to interact with data container objects. It provides a common "
"interface to extract and set data without having to take the object's type "
"into account."
msgstr "データ・コンテナ・オブジェクトと対話するラッパー・クラス。 オブジェクトの型を考慮せずにデータを抽出および設定するための共通のインターフェースを提供します。"

#: ../../../venv/lib/python3.8/site-packages/itemadapter/utils.py:docstring of
#: itemadapter.utils.is_item:1
msgid ""
"Return True if the given object belongs to one of the supported types, False "
"otherwise."
msgstr "指定されたオブジェクトがサポートされている型の1つに属している場合はTrueを返し、そうでない場合はFalseを返します。"

#: ../../../venv/lib/python3.8/site-packages/itemadapter/utils.py:docstring of
#: itemadapter.utils.is_item:3
msgid "Alias for ItemAdapter.is_item"
msgstr "ItemAdapter.is_item のエイリアス"

#: ../../topics/items.rst:387
msgid "Other classes related to items"
msgstr "アイテムに関連する他のクラス"

#: ../../../scrapy/item.py:docstring of scrapy.item.ItemMeta:1
msgid "Metaclass_ of :class:`Item` that handles field definitions."
msgstr "フィールド定義を処理する :class:`Item` の Metaclass_ 。"
