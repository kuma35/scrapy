# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2008–2018, Scrapy developers
# This file is distributed under the same license as the Scrapy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Scrapy \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-04-10 01:26+0900\n"
"PO-Revision-Date: 2021-05-15 04:37+0900\n"
"Last-Translator: kuma35\n"
"Language-Team: Japanese\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../../topics/loaders.rst:5
msgid "Item Loaders"
msgstr "アイテム・ローダー"

#: ../../topics/loaders.rst:10
msgid ""
"Item Loaders provide a convenient mechanism for populating scraped :ref:"
"`items <topics-items>`. Even though items can be populated directly, Item "
"Loaders provide a much more convenient API for populating them from a "
"scraping process, by automating some common tasks like parsing the raw "
"extracted data before assigning it."
msgstr ""
"アイテムローダーは、スクレイピングされた :ref:`アイテム<topics-items>` を生成"
"するための便利なメカニズムを提供します。 アイテムは独自の辞書のようなAPIを使"
"用して入力できますが、アイテムローダーは、生の抽出データを割り当てる前に解析"
"するなどの一般的なタスクを自動化することにより、スクレイピングプロセスからア"
"イテムを入力するための、はるかに便利なAPIを提供します。"

#: ../../topics/loaders.rst:15
msgid ""
"In other words, :ref:`items <topics-items>` provide the *container* of "
"scraped data, while Item Loaders provide the mechanism for *populating* that "
"container."
msgstr ""
"言い換えると、 :ref:`アイテム<topics-items>` はスクレイピングされたデータの *"
"コンテナ* を提供し、アイテム・ローダーはそのコンテナに *格納* するメカニズム"
"を提供します。"

#: ../../topics/loaders.rst:19
msgid ""
"Item Loaders are designed to provide a flexible, efficient and easy "
"mechanism for extending and overriding different field parsing rules, either "
"by spider, or by source format (HTML, XML, etc) without becoming a nightmare "
"to maintain."
msgstr ""
"アイテム・ローダーは、スパイダーまたはソース形式(HTML、XMLなど)）によってさま"
"ざまなフィールド・パース・ルールを拡張およびオーバーライドするための柔軟で効"
"率的かつ簡単なメカニズムを提供するように設計されています。"

#: ../../topics/loaders.rst:23
msgid ""
"Item Loaders are an extension of the itemloaders_ library that make it "
"easier to work with Scrapy by adding support for :ref:`responses <topics-"
"request-response>`."
msgstr ""

#: ../../topics/loaders.rst:28
msgid "Using Item Loaders to populate items"
msgstr "アイテムを格納するためにアイテム・ローダーを使う"

#: ../../topics/loaders.rst:30
#, fuzzy
msgid ""
"To use an Item Loader, you must first instantiate it. You can either "
"instantiate it with an :ref:`item object <topics-items>` or without one, in "
"which case an :ref:`item object <topics-items>` is automatically created in "
"the Item Loader ``__init__`` method using the :ref:`item <topics-items>` "
"class specified in the :attr:`ItemLoader.default_item_class` attribute."
msgstr "アイテム・ローダーを使用するには、最初にインスタンス化する必要があります。 あなたは :ref:`アイテム・オブジェクト <topics-items>` を使用して、または使用せずにインスタンス化することができます。使用せずにインスタンス化する場合、:ref:`アイテム・オブジェクト<topics-items>` はアイテム・ローダーの ``__init__``メソッド内で、 :attr:`ItemLoader.default_item_class` 属性で指定された :ref:`アイテム <topics-items>` を使用して自動的に生成されます。"

#: ../../topics/loaders.rst:36
msgid ""
"Then, you start collecting values into the Item Loader, typically using :ref:"
"`Selectors <topics-selectors>`. You can add more than one value to the same "
"item field; the Item Loader will know how to \"join\" those values later "
"using a proper processing function."
msgstr ""
"それから、通常は :ref:`セレクター<topics-selectors>` を使用して、あなたはアイ"
"テム・ローダーへの値の収集を開始します。 同じアイテム・フィールドに複数の値を"
"追加できます。アイテム・ローダーは、適切な処理機能を使用して、それらの値を後"
"で「結合」(join)する方法を知っています。"

#: ../../topics/loaders.rst:41
msgid ""
"Collected data is internally stored as lists, allowing to add several values "
"to the same field. If an ``item`` argument is passed when creating a loader, "
"each of the item's values will be stored as-is if it's already an iterable, "
"or wrapped with a list if it's a single value."
msgstr ""

#: ../../topics/loaders.rst:47
msgid ""
"Here is a typical Item Loader usage in a :ref:`Spider <topics-spiders>`, "
"using the :ref:`Product item <topics-items-declaring>` declared in the :ref:"
"`Items chapter <topics-items>`::"
msgstr ""
"以下は、 :ref:`アイテムの章<topics-items>` で宣言された :ref:`Product item "
"<topics-items-declaring>` を使用した、:ref:`スパイダー<topics-spiders>` 内で"
"の典型的なアイテム・ローダーの使用法です::"

#: ../../topics/loaders.rst:63
msgid ""
"By quickly looking at that code, we can see the ``name`` field is being "
"extracted from two different XPath locations in the page:"
msgstr ""
"そのコードをざっと見ると、ページ内の2つの異なるXPathロケーションから "
"``name`` フィールドが抽出されていることがわかります:"

#: ../../topics/loaders.rst:66
msgid "``//div[@class=\"product_name\"]``"
msgstr "``//div[@class=\"product_name\"]``"

#: ../../topics/loaders.rst:67
msgid "``//div[@class=\"product_title\"]``"
msgstr "``//div[@class=\"product_title\"]``"

#: ../../topics/loaders.rst:69
msgid ""
"In other words, data is being collected by extracting it from two XPath "
"locations, using the :meth:`~ItemLoader.add_xpath` method. This is the data "
"that will be assigned to the ``name`` field later."
msgstr ""
"いいかえると、データは、 :meth:`~ItemLoader.add_xpath` メソッドを使用して、2"
"つのXPathロケーションから抽出することで収集されます。 これは後で ``name`` "
"フィールドに割り当てられるデータです。"

#: ../../topics/loaders.rst:73
msgid ""
"Afterwards, similar calls are used for ``price`` and ``stock`` fields (the "
"latter using a CSS selector with the :meth:`~ItemLoader.add_css` method), "
"and finally the ``last_update`` field is populated directly with a literal "
"value (``today``) using a different method: :meth:`~ItemLoader.add_value`."
msgstr ""
"その後、同様の呼び出しが ``price`` および ``stock`` フィールド(後者は :meth:"
"`~ItemLoader.add_css` メソッドでCSSセレクターを使用)に対して行われ、おわりに "
"``last_update`` フィールドは :meth:`~ItemLoader.add_value` という別のメソッド"
"を使用して、リテラル値( ``today`` )を直接入力します:"

#: ../../topics/loaders.rst:78
msgid ""
"Finally, when all data is collected, the :meth:`ItemLoader.load_item` method "
"is called which actually returns the item populated with the data previously "
"extracted and collected with the :meth:`~ItemLoader.add_xpath`, :meth:"
"`~ItemLoader.add_css`, and :meth:`~ItemLoader.add_value` calls."
msgstr ""
"すべてのデータが収集されると、最後に、 :meth:`ItemLoader.load_item` メソッド"
"が呼び出され、実際に返されるのは、以前に :meth:`~ItemLoader.add_xpath` や :"
"meth:`~ItemLoader.add_css` や :meth:`~ItemLoader.add_value` の呼び出しで収集"
"したデータを格納したアイテムです。"

#: ../../topics/loaders.rst:87
msgid "Working with dataclass items"
msgstr ""

#: ../../topics/loaders.rst:89
msgid ""
"By default, :ref:`dataclass items <dataclass-items>` require all fields to "
"be passed when created. This could be an issue when using dataclass items "
"with item loaders: unless a pre-populated item is passed to the loader, "
"fields will be populated incrementally using the loader's :meth:`~ItemLoader."
"add_xpath`, :meth:`~ItemLoader.add_css` and :meth:`~ItemLoader.add_value` "
"methods."
msgstr ""

#: ../../topics/loaders.rst:95
msgid ""
"One approach to overcome this is to define items using the :func:"
"`~dataclasses.field` function, with a ``default`` argument::"
msgstr ""

#: ../../topics/loaders.rst:111
msgid "Input and Output processors"
msgstr "入力プロセッサと出力プロセッサ"

#: ../../topics/loaders.rst:113
msgid ""
"An Item Loader contains one input processor and one output processor for "
"each (item) field. The input processor processes the extracted data as soon "
"as it's received (through the :meth:`~ItemLoader.add_xpath`, :meth:"
"`~ItemLoader.add_css` or :meth:`~ItemLoader.add_value` methods) and the "
"result of the input processor is collected and kept inside the ItemLoader. "
"After collecting all data, the :meth:`ItemLoader.load_item` method is called "
"to populate and get the populated :ref:`item object <topics-items>`.  That's "
"when the output processor is called with the data previously collected (and "
"processed using the input processor). The result of the output processor is "
"the final value that gets assigned to the item."
msgstr "アイテムローダーには、各(アイテム)フィールドごとに1つの入力プロセッサと1つの出力プロセッサが含まれます。入力プロセッサは、( :meth:`~ItemLoader.add_xpath` または :meth:`~ItemLoader.add_css` または :meth:`~ItemLoader.add_value` メソッドを介して)受信したデータをすぐに処理し、入力プロセッサの結果が収集されてアイテム・ローダー内に保持されます。すべてのデータを収集した後、 :meth:`ItemLoader.load_item` メソッドが呼び出されてデータを格納し、データが格納された :ref:`アイテム・オブジェクト <topics-items>` を取得します。その時点で、以前に収集された(および入力プロセッサを使用して処理された)データを使用して、出力プロセッサが呼び出されます。出力プロセッサの結果は、アイテムに割り当てられる最終値です。"

#: ../../topics/loaders.rst:124
msgid ""
"Let's see an example to illustrate how the input and output processors are "
"called for a particular field (the same applies for any other field)::"
msgstr ""
"(他の任意のフィールドにも同じことが当てはまりますが)とあるフィールドに対して"
"入力プロセッサおよび出力プロセッサがどのように呼び出されるかを例で見てみま"
"しょう::"

#: ../../topics/loaders.rst:134
msgid "So what happens is:"
msgstr "以下のステップがあります:"

#: ../../topics/loaders.rst:136
msgid ""
"Data from ``xpath1`` is extracted, and passed through the *input processor* "
"of the ``name`` field. The result of the input processor is collected and "
"kept in the Item Loader (but not yet assigned to the item)."
msgstr ""
"``xpath1`` からのデータが抽出され、 ``name`` フィールドの *入力プロセッサ* を"
"通過します。 入力プロセッサの結果が収集され、アイテムローダーに保持されます"
"(ただし、アイテムにはまだ割り当てられていません)。"

#: ../../topics/loaders.rst:140
msgid ""
"Data from ``xpath2`` is extracted, and passed through the same *input "
"processor* used in (1). The result of the input processor is appended to the "
"data collected in (1) (if any)."
msgstr ""
"``xpath2`` からのデータが抽出され、ステップ(1)で使用されたのと同じ *入力プロ"
"セッサ* を通過します。 入力プロセッサの結果は、(存在する場合、)ステップ(1)で"
"収集されたデータに追加されます。"

#: ../../topics/loaders.rst:144
msgid ""
"This case is similar to the previous ones, except that the data is extracted "
"from the ``css`` CSS selector, and passed through the same *input processor* "
"used in (1) and (2). The result of the input processor is appended to the "
"data collected in (1) and (2) (if any)."
msgstr ""
"この場合は、データが ``css`` CSSセレクターから抽出され、ステップ(1)とステップ"
"(2)で使用された同じ *入力プロセッサ* を通過することを除いて、以前の場合と似て"
"います。 入力プロセッサの結果は、(存在する場合、)ステップ(1)およびステップ(2)"
"で収集されたデータに追加されます。"

#: ../../topics/loaders.rst:149
msgid ""
"This case is also similar to the previous ones, except that the value to be "
"collected is assigned directly, instead of being extracted from a XPath "
"expression or a CSS selector. However, the value is still passed through the "
"input processors. In this case, since the value is not iterable it is "
"converted to an iterable of a single element before passing it to the input "
"processor, because input processor always receive iterables."
msgstr ""
"この場合も以前の場合と似ていますが、XPath式またはCSSセレクターから抽出される"
"のではなく、収集される値が直接割り当てられる点が異なります。 ただし、値は引き"
"続き入力プロセッサを介して渡されます。 この場合、値は反復可能ではなく(not "
"iterable)、そして、入力プロセッサに常に反復可能要素を受け取るため(always "
"receive iterables)、入力プロセッサに渡す前に単一の要素の反復可能要素に変換さ"
"れます。"

#: ../../topics/loaders.rst:157
msgid ""
"The data collected in steps (1), (2), (3) and (4) is passed through the "
"*output processor* of the ``name`` field. The result of the output processor "
"is the value assigned to the ``name`` field in the item."
msgstr ""
"ステップ(1)〜(4)で収集されたデータは、 ``name`` フィールドの *出力プロセッサ"
"* を介して渡されます。 出力プロセッサの結果は、アイテムの ``name`` フィールド"
"に割り当てられた値です。"

#: ../../topics/loaders.rst:162
msgid ""
"It's worth noticing that processors are just callable objects, which are "
"called with the data to be parsed, and return a parsed value. So you can use "
"any function as input or output processor. The only requirement is that they "
"must accept one (and only one) positional argument, which will be an "
"iterable."
msgstr "プロセッサは、パース対象のデータとともに呼び出され、パースされた値を返す、呼び出し可能なオブジェクトにすぎないことに注意してください。 したがって、任意の関数を入力または出力プロセッサとして使用できます。 唯一の要件は、反復可能(iterable)な1つの(そして1つだけの)位置引数を受け入れる必要があることです。"

#: ../../topics/loaders.rst:167
msgid "Processors no longer need to be methods."
msgstr ""

#: ../../topics/loaders.rst:170
msgid ""
"Both input and output processors must receive an iterable as their first "
"argument. The output of those functions can be anything. The result of input "
"processors will be appended to an internal list (in the Loader) containing "
"the collected values (for that field). The result of the output processors "
"is the value that will be finally assigned to the item."
msgstr ""
"入力プロセッサと出力プロセッサは両方とも、イテレータを最初の引数として受け取"
"る必要があります。 これらの関数の出力は何でもかまいません。 入力プロセッサの"
"結果は、(そのフィールドのために)収集された値を含む(ローダー内の)内部リストに"
"追加されます。出力プロセッサの結果は、最終的にアイテムに割り当てられる値で"
"す。"

#: ../../topics/loaders.rst:176
msgid ""
"The other thing you need to keep in mind is that the values returned by "
"input processors are collected internally (in lists) and then passed to "
"output processors to populate the fields."
msgstr ""
"もう1つ注意する必要があるのは、入力プロセッサから返される値が内部(リスト)で収"
"集され、出力プロセッサに渡されてフィールドに入力されることです。"

#: ../../topics/loaders.rst:180
#, fuzzy
msgid ""
"Last, but not least, itemloaders_ comes with some :ref:`commonly used "
"processors <itemloaders:built-in-processors>` built-in for convenience."
msgstr "なお、 itemloaders_ には便宜上いくつかの :ref:`一般的なプロセッサ <itemloaders:built-in-processors>` が組み込まれています。"

#: ../../topics/loaders.rst:185
msgid "Declaring Item Loaders"
msgstr "アイテム・ローダーの宣言"

#: ../../topics/loaders.rst:187
msgid ""
"Item Loaders are declared using a class definition syntax. Here is an "
"example::"
msgstr "アイテム・ローダーは、クラス定義構文を使用して宣言されます。 以下に例を示します::"

#: ../../topics/loaders.rst:203
msgid ""
"As you can see, input processors are declared using the ``_in`` suffix while "
"output processors are declared using the ``_out`` suffix. And you can also "
"declare a default input/output processors using the :attr:`ItemLoader."
"default_input_processor` and :attr:`ItemLoader.default_output_processor` "
"attributes."
msgstr ""
"ご覧のように、入力プロセッサは ``_in`` 接尾辞を使用して宣言され、出力プロセッ"
"サは ``_out`` 接尾辞を使用して宣言されています。 また、 :attr:`ItemLoader."
"default_input_processor` と :attr:`ItemLoader.default_output_processor` 属性"
"を使用して、デフォルトの入出力プロセッサを宣言することもできます。"

#: ../../topics/loaders.rst:212
msgid "Declaring Input and Output Processors"
msgstr "入力プロセッサと出力プロセッサの宣言"

#: ../../topics/loaders.rst:214
msgid ""
"As seen in the previous section, input and output processors can be declared "
"in the Item Loader definition, and it's very common to declare input "
"processors this way. However, there is one more place where you can specify "
"the input and output processors to use: in the :ref:`Item Field <topics-"
"items-fields>` metadata. Here is an example::"
msgstr ""
"前述のとおり、入力プロセッサと出力プロセッサはアイテム・ローダー定義で宣言で"
"きます。この方法で入力プロセッサを宣言することは非常に一般的です。 ただし、使"
"用する入力プロセッサと出力プロセッサを指定できる場所がもう1つあります。 :ref:"
"`アイテム・フィールド<topics-items-fields>` メタデータです。以下に例を示しま"
"す::"

#: ../../topics/loaders.rst:245
msgid ""
"The precedence order, for both input and output processors, is as follows:"
msgstr "入力プロセッサと出力プロセッサの両方の優先順位は次のとおりです::"

#: ../../topics/loaders.rst:247
msgid ""
"Item Loader field-specific attributes: ``field_in`` and ``field_out`` (most "
"precedence)"
msgstr ""
"アイテムローダーのフィールド固有の属性: ``field_in`` および ``field_out`` (最"
"優先)"

#: ../../topics/loaders.rst:249
msgid "Field metadata (``input_processor`` and ``output_processor`` key)"
msgstr ""
"フィールド・メタデータ(``input_processor`` と ``output_processor`` キー)"

#: ../../topics/loaders.rst:250
msgid ""
"Item Loader defaults: :meth:`ItemLoader.default_input_processor` and :meth:"
"`ItemLoader.default_output_processor` (least precedence)"
msgstr ""
"アイテム・ローダー デフォルト： :meth:`ItemLoader.default_input_processor` "
"と :meth:`ItemLoader.default_output_processor` (最も低い優先度)"

#: ../../topics/loaders.rst:253
msgid "See also: :ref:`topics-loaders-extending`."
msgstr ":ref:`topics-loaders-extending` も参照下さい。"

#: ../../topics/loaders.rst:258
msgid "Item Loader Context"
msgstr "アイテム・ローダー・コンテキスト"

#: ../../topics/loaders.rst:260
msgid ""
"The Item Loader Context is a dict of arbitrary key/values which is shared "
"among all input and output processors in the Item Loader. It can be passed "
"when declaring, instantiating or using Item Loader. They are used to modify "
"the behaviour of the input/output processors."
msgstr ""
"アイテムローダーコンテキストは、アイテムローダーのすべての入力プロセッサおよ"
"び出力プロセッサ間で共有される任意のキー・値ペアの辞書です。アイテム・ロー"
"ダーの宣言、インスタンス化、または使用時に渡すことができます。これらは、入出"
"力プロセッサの動作を変更するために使用されます。"

#: ../../topics/loaders.rst:265
msgid ""
"For example, suppose you have a function ``parse_length`` which receives a "
"text value and extracts a length from it::"
msgstr ""
"たとえば、テキスト値を受け取り、そこから長さを抽出する ``parse_length`` 関数"
"があるとします::"

#: ../../topics/loaders.rst:273
msgid ""
"By accepting a ``loader_context`` argument the function is explicitly "
"telling the Item Loader that it's able to receive an Item Loader context, so "
"the Item Loader passes the currently active context when calling it, and the "
"processor function (``parse_length`` in this case) can thus use them."
msgstr ""
"``loader_context`` 引数を受け入れることにより、プロセッサ関数はアイテム・ロー"
"ダーがアイテム・ローダー・コンテキストを受け取ることができることを明示的に伝"
"えています。そのため、アイテム・ローダーはプロセッサ関数呼び出し時に現在アク"
"ティブなコンテキストを渡します。よってプロセッサ関数(この場合 "
"``parse_length``)は現在アクティブなコンテキストを使用できます。"

#: ../../topics/loaders.rst:278
msgid "There are several ways to modify Item Loader context values:"
msgstr "アイテムローダーのコンテキスト値を変更する方法はいくつかあります:"

#: ../../topics/loaders.rst:280
msgid ""
"By modifying the currently active Item Loader context (:attr:`~ItemLoader."
"context` attribute)::"
msgstr ""
"現在アクティブなアイテム・ローダー・コンテキスト( :attr:`~ItemLoader."
"context` 属性)を変更する::"

#: ../../topics/loaders.rst:286
#, fuzzy
#| msgid ""
#| "On Item Loader instantiation (the keyword arguments of Item Loader "
#| "constructor are stored in the Item Loader context)::"
msgid ""
"On Item Loader instantiation (the keyword arguments of Item Loader "
"``__init__`` method are stored in the Item Loader context)::"
msgstr ""
"アイテム・ローダーのインスタンス化時(アイテム・ローダー・コンストラクターの"
"キーワード引数は、アイテム・ローダー・コンテキストに保存されます)::"

#: ../../topics/loaders.rst:291
msgid ""
"On Item Loader declaration, for those input/output processors that support "
"instantiating them with an Item Loader context. :class:`~processor."
"MapCompose` is one of them::"
msgstr ""
"アイテム・ローダーの宣言で、アイテム・ローダー・コンテキストを使用したインス"
"タンス化をサポートする入出力プロセッサ用。 :class:`~processor.MapCompose` は"
"それらの1つです::"

#: ../../topics/loaders.rst:300
msgid "ItemLoader objects"
msgstr "ItemLoaderオブジェクト"

#: ../../topics/loaders.rst:309
msgid "Nested Loaders"
msgstr "入れ子になったローダー"

#: ../../topics/loaders.rst:311
msgid ""
"When parsing related values from a subsection of a document, it can be "
"useful to create nested loaders.  Imagine you're extracting details from a "
"footer of a page that looks something like:"
msgstr "ドキュメントのサブセクションから関連する値をパースする場合、入れ子になったローダーを作成すると便利です。以下のようなページのフッターから詳細を抽出しているとします:"

#: ../../topics/loaders.rst:315 ../../topics/loaders.rst:326
#: ../../topics/loaders.rst:338
msgid "Example::"
msgstr "例::"

#: ../../topics/loaders.rst:323
msgid ""
"Without nested loaders, you need to specify the full xpath (or css) for each "
"value that you wish to extract."
msgstr "入れ子になったローダーがない場合、あなたは抽出する値ごとに完全なxpath(またはcss)を指定する必要があります。"

#: ../../topics/loaders.rst:334
msgid ""
"Instead, you can create a nested loader with the footer selector and add "
"values relative to the footer.  The functionality is the same but you avoid "
"repeating the footer selector."
msgstr "代わりに、あなたはフッター・セレクターを使用して入れ子になったローダーを作成し、フッターに関連する値を追加できます。機能は同じですが、あなたはフッター・セレクターの繰り返しを回避できます。"

# overboard意味不明…強調するような物言いっぽいので単に省く。
#: ../../topics/loaders.rst:348
msgid ""
"You can nest loaders arbitrarily and they work with either xpath or css "
"selectors. As a general guideline, use nested loaders when they make your "
"code simpler but do not go overboard with nesting or your parser can become "
"difficult to read."
msgstr "あなたはローダーを任意に入れ子にでき、xpathまたはcssセレクターで動作します。 一般的なガイドラインとして、入れ子になったローダーを使用してコードを単純化します。入れ子にしないと、パーサーが読みにくくなる可能性があります。"

#: ../../topics/loaders.rst:355
msgid "Reusing and extending Item Loaders"
msgstr "アイテムローダーの再利用と拡張"

#: ../../topics/loaders.rst:357
msgid ""
"As your project grows bigger and acquires more and more spiders, maintenance "
"becomes a fundamental problem, especially when you have to deal with many "
"different parsing rules for each spider, having a lot of exceptions, but "
"also wanting to reuse the common processors."
msgstr ""
"あなたのプロジェクトが大きくなり、ますます多くのスパイダーを取得するにつれ"
"て、メンテナンスは根本的な問題になります。特に、各スパイダーの多くの異なる"
"パースルールを処理する必要がある場合、多くの例外があります。また、共通のプロ"
"セッサを再利用したい場合も同様です。"

#: ../../topics/loaders.rst:362
msgid ""
"Item Loaders are designed to ease the maintenance burden of parsing rules, "
"without losing flexibility and, at the same time, providing a convenient "
"mechanism for extending and overriding them. For this reason Item Loaders "
"support traditional Python class inheritance for dealing with differences of "
"specific spiders (or groups of spiders)."
msgstr ""
"アイテムローダーは、柔軟性を失うことなく、パースルールのメンテナンスの負担を"
"軽減するように設計されていると同時に、それらを拡張およびオーバーライドするた"
"めの便利なメカニズムを提供します。このため、アイテムローダーは、特定のスパイ"
"ダー(またはスパイダーのグループ)の違いを処理するために、従来のPythonクラスの"
"継承をサポートしています。"

#: ../../topics/loaders.rst:368
msgid ""
"Suppose, for example, that some particular site encloses their product names "
"in three dashes (e.g. ``---Plasma TV---``) and you don't want to end up "
"scraping those dashes in the final product names."
msgstr ""
"たとえば、ある特定のサイトが製品名を3つのダッシュ(たとえば ``---Plasma TV---"
"`` )で囲んでおり、最終製品名でそれらのダッシュをスクレイピングしたくないと仮"
"定します。"

#: ../../topics/loaders.rst:372
msgid ""
"Here's how you can remove those dashes by reusing and extending the default "
"Product Item Loader (``ProductLoader``)::"
msgstr ""
"ここで、デフォルトの製品アイテムローダー( ``ProductLoader`` )を再利用して拡張"
"することで、これらのダッシュを削除する方法を次に示します::"

#: ../../topics/loaders.rst:384
msgid ""
"Another case where extending Item Loaders can be very helpful is when you "
"have multiple source formats, for example XML and HTML. In the XML version "
"you may want to remove ``CDATA`` occurrences. Here's an example of how to do "
"it::"
msgstr ""
"アイテムローダーの拡張が非常に役立つ別のケースは、XMLやHTMLなどの複数のソース"
"形式がある場合です。XMLバージョンでは、 ``CDATA`` の出現を削除することができ"
"ます。方法の例を次に示します::"

#: ../../topics/loaders.rst:395
msgid "And that's how you typically extend input processors."
msgstr "そして、それは、入力プロセッサを拡張する典型的な方法です。"

#: ../../topics/loaders.rst:397
msgid ""
"As for output processors, it is more common to declare them in the field "
"metadata, as they usually depend only on the field and not on each specific "
"site parsing rule (as input processors do). See also: :ref:`topics-loaders-"
"processors-declaring`."
msgstr ""
"出力プロセッサについては、フィールドメタデータで宣言する方が一般的です。これ"
"は、通常、(入力プロセッサのように)特定の各サイトのパースルールではなく、"
"フィールドのみに依存するためです。 :ref:`topics-loaders-processors-"
"declaring` も参照してください。"

#: ../../topics/loaders.rst:402
msgid ""
"There are many other possible ways to extend, inherit and override your Item "
"Loaders, and different Item Loaders hierarchies may fit better for different "
"projects. Scrapy only provides the mechanism; it doesn't impose any specific "
"organization of your Loaders collection - that's up to you and your "
"project's needs."
msgstr ""
"アイテムローダーを拡張、継承、およびオーバーライドする方法は他にもたくさんあ"
"ります。さまざまなアイテムローダーの階層は、さまざまなプロジェクトにより適し"
"ています。 Scrapyはメカニズムのみを提供します。 ローダーコレクションの特定の"
"構成を強制することはありません。それはあなたとプロジェクトのニーズ次第です。"
